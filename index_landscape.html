<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title>BulletHell-Mobile (Landscape Single File)</title>
  <style>
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body { margin:0; padding:0; width:100%; height:100%; background:#000; color:#fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; overflow:hidden; }
    button { border:0; border-radius:14px; padding:12px 18px; font-size:16px; background:#14b8a6; color:#000; font-weight:700; }
    button:active { transform: scale(0.98); }
    #stage { position: absolute; left:50%; top:50%; transform: translate(-50%,-50%) scale(1); transform-origin: top left; }
    #canvasWrap { position: relative; width:900px; height:600px; }
    #mainMenu { position:absolute; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:14px; }
    #highScore { opacity:0.9; }
    .overlay { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; text-align:center; }
    .overlay .card { background:rgba(20,20,20,0.9); padding:20px; border:1px solid #333; border-radius:16px; width:min(90%, 420px); }
    #warning { font-size:28px; color:#ff5555; font-weight:900; text-shadow: 0 2px 8px rgba(255,0,0,0.6); display:none; }
    #gameCanvas { background:#000; display:none; }
    #ui { position:absolute; inset:0; pointer-events:none; display:none; }
    #hudTop { position:absolute; top:10px; left:10px; right:10px; display:flex; gap:10px; align-items:center; justify-content:space-between; }
    #hpBarContainer { position:relative; display:flex; align-items:center; gap:8px; }
    #hpBarContainer label { font-size:12px; opacity:0.9; }
    #hpBar { width:200px; height:18px; background:#333; border:1px solid #666; border-radius:10px; overflow:hidden; }
    #hpBar>div { height:100%; width:100%; background:#22c55e; }
    #hpText { position:absolute; left:36px; top:0; width:200px; height:18px; line-height:18px; text-align:center; font-size:12px; color:#fff; text-shadow:0 1px 2px #000; }
    #bossUi { position:absolute; top:40px; left:10px; right:10px; display:none; align-items:center; gap:8px; }
    #bossHpBar { flex:1; height:12px; background:#222; border:1px solid #555; border-radius:8px; overflow:hidden; }
    #bossHpBar>div { height:100%; width:100%; background:#ef4444; }
    #scoreContainer label { font-size:12px; opacity:0.9; margin-right:6px; }
    #scoreContainer span { font-size:18px; font-weight:800; }
    /* 조이스틱 (좌하단) */
    #joystick { position:absolute; left:16px; bottom:16px; width:120px; height:120px; border-radius:50%; background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.15); display:none; }
    #stick { position:absolute; left:50%; top:50%; width:56px; height:56px; margin-left:-28px; margin-top:-28px; border-radius:50%; background:rgba(255,255,255,0.2); border:1px solid rgba(255,255,255,0.35); }
  </style>
</head>
<body>
  <!-- 고정 크기 스테이지(900x600)를 화면에 맞게 스케일 -->
  <div id="stage">
    <div id="canvasWrap">
      <!-- 메인 메뉴 -->
      <div id="mainMenu">
        <h1>BulletHell (Landscape)</h1>
        <button id="btnStart">게임 시작</button>
        <div id="highScore">최고 점수(로컬): <span id="best">0</span></div>
      </div>
      <!-- 경고 -->
      <div id="warning" class="overlay">⚠️ 보스 곧 등장! ⚠️</div>
      <!-- 캔버스 -->
      <canvas id="gameCanvas" width="900" height="600"></canvas>
      <!-- HUD -->
      <div id="ui">
        <div id="hudTop">
          <div id="hpBarContainer">
            <label>HP</label>
            <div id="hpBar"><div></div></div>
            <div id="hpText"></div>
          </div>
          <div id="scoreContainer">
            <label>점수</label><span id="score">0</span>
          </div>
        </div>
        <div id="bossUi">
          <label>Boss</label>
          <div id="bossHpBar"><div></div></div>
        </div>
      </div>
      <!-- 조이스틱 -->
      <div id="joystick"><div id="stick"></div></div>
      <!-- 게임오버 -->
      <div id="gameOverScreen" class="overlay" style="display:none">
        <div class="card">
          <h2>게임 오버</h2>
          <div>최종 점수: <span id="finalScore">0</span></div>
          <button id="btnRetry">다시하기</button>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    // ====== DOM ======
    const stage = document.getElementById('stage');
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha:false });
    const btnStart = document.getElementById('btnStart');
    const btnRetry = document.getElementById('btnRetry');
    const mainMenu = document.getElementById('mainMenu');
    const ui = document.getElementById('ui');
    const warningDiv = document.getElementById('warning');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const finalScore = document.getElementById('finalScore');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const hpFill = document.querySelector('#hpBar>div');
    const hpText = document.getElementById('hpText');
    const bossUi = document.getElementById('bossUi');
    const bossHpFill = document.querySelector('#bossHpBar>div');
    const joystick = document.getElementById('joystick');
    const stick = document.getElementById('stick');

    // ====== Stage scale (fit to viewport, keep aspect 900x600) ======
    function fitStage(){
      const sw = 900, sh = 600;
      const scale = Math.min(window.innerWidth / sw, window.innerHeight / sh);
      stage.style.transform = \`translate(-50%,-50%) scale(\${scale})\`;
    }
    fitStage();
    window.addEventListener('resize', fitStage);
    window.addEventListener('orientationchange', () => setTimeout(fitStage, 100));

    // ====== Game State ======
    let lastTime = performance.now();
    const FRAME_REF = 16.6667;
    const SCORE_PER_SEC = 60;

    let player, bullets, healthPacks, score, gameOver, spawnIntervalMs, spawnTimerMs, difficultyTimerMs;
    let nextBossIdx, bossSchedule, bossActive, bossTimerMs, bossDurationMs, lastHealThreshold, lastMaxHpThreshold, boss;

    // ====== Input ======
    let input = { ax: 0, ay: 0 };
    const JOY_RADIUS = 50, STICK_RADIUS = 24;
    const keys = {};

    // ====== Entities ======
    class Bullet {
      constructor(x,y,vx,vy,r,color,dmg){ this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.r=r; this.color=color; this.dmg=dmg; }
      static aimedFromEdge(){
        let x,y;
        if(Math.random()<0.5){ x=Math.random()*canvas.width; y=Math.random()<0.5?0:canvas.height; }
        else { x=Math.random()<0.5?0:canvas.width; y=Math.random()*canvas.height; }
        const dx=player.x-x, dy=player.y-y;
        const L=Math.hypot(dx,dy)||1;
        const sp=3 + score/5000;
        const vx=dx/L*sp, vy=dy/L*sp;
        return new Bullet(x,y,vx,vy,5,'#f00', player.maxHp/15);
      }
      update(dt){ const k=dt/FRAME_REF; this.x+=this.vx*k; this.y+=this.vy*k; }
      draw(){ ctx.fillStyle=this.color; ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fill(); }
      inBounds(){ return (this.x>=-20&&this.x<=canvas.width+20&&this.y>=-20&&this.y<=canvas.height+20); }
    }

    class HealthPack {
      constructor(){ this.r=10; this.color='#ff66cc'; this.x=Math.random()*(canvas.width-30)+15; this.y=Math.random()*(canvas.height-30)+15; }
      draw(){
        ctx.fillStyle=this.color;
        ctx.beginPath();
        const topCurve = this.r * 0.3;
        ctx.moveTo(this.x, this.y + this.r * 0.3);
        ctx.bezierCurveTo(this.x - this.r, this.y - topCurve,
                          this.x - this.r*1.5, this.y + this.r*0.8,
                          this.x, this.y + this.r*1.6);
        ctx.bezierCurveTo(this.x + this.r*1.5, this.y + this.r*0.8,
                          this.x + this.r, this.y - topCurve,
                          this.x, this.y + this.r * 0.3);
        ctx.closePath(); ctx.fill();
      }
    }

    class Boss {
      constructor(){ this.size=90; this.x=canvas.width/2; this.y=canvas.height/2; this.maxHp=400; this.hp=this.maxHp; this.t=0; this.phase='burst'; }
      draw(){ ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.t*0.002); ctx.fillStyle='#0ff'; const s=this.size; ctx.fillRect(-s/2,-s/2,s,s); ctx.restore(); }
      update(dt){
        this.t+=dt;
        const r=this.hp/this.maxHp;
        if(r>=0.70) this.phase='burst'; else if(r>=0.40) this.phase='spiral'; else this.phase='aimed';
        const bossDmg = player.maxHp/15*2;
        if(this.phase==='burst'){
          if(this.t%800<dt){ const n=16; for(let i=0;i<n;i++){ const a=(2*Math.PI*i)/n; bullets.push(new Bullet(this.x,this.y,Math.cos(a)*2.2,Math.sin(a)*2.2,6,'#ff0',bossDmg)); } }
        } else if(this.phase==='spiral'){
          if(this.t%40<dt){ const a=(performance.now()/30)%(2*Math.PI); bullets.push(new Bullet(this.x,this.y,Math.cos(a)*2.8,Math.sin(a)*2.8,5.5,'#ffa500',bossDmg)); }
        } else {
          if(this.t%500<dt){ for(let k=0;k<3;k++){ setTimeout(()=>{ if(!bossActive) return; const dx=player.x-this.x, dy=player.y-this.y; const L=Math.hypot(dx,dy)||1; const vx=dx/L*3.6, vy=dy/L*3.6; bullets.push(new Bullet(this.x,this.y,vx,vy,6,'#0ff',bossDmg)); }, k*100); } }
        }
        const hpDecay = this.maxHp/15000 * dt;
        this.hp = Math.max(0, this.hp - hpDecay);
      }
    }

    // ====== UI Helpers ======
    function updateHpBar(){
      const pct = Math.max(0, player.hp)/player.maxHp;
      hpFill.style.width = \`\${200*Math.max(0,Math.min(1,pct))}px\`;
      hpText.textContent = \`\${Math.floor(player.hp)}/\${Math.floor(player.maxHp)}\`;
    }
    function updateBossBar(){
      if(bossActive && boss){ bossUi.style.display='flex'; bossHpFill.style.width = \`\${Math.max(0,Math.min(1,boss.hp/boss.maxHp))*100}%\`; }
      else { bossUi.style.display='none'; }
    }
    function maybeSpawnBoss(){
      if(nextBossIdx<bossSchedule.length && score>=bossSchedule[nextBossIdx]){
        warningDiv.style.display='flex';
        setTimeout(()=>{
          warningDiv.style.display='none';
          bossActive=true; bossTimerMs=0; boss=new Boss();
          updateBossBar();
        }, 1000);
        nextBossIdx++;
      }
    }

    // ====== Joystick ======
    let joyActive=false, joyCx=0, joyCy=0;
    function setStick(dx, dy){
      const len = Math.hypot(dx,dy);
      const max = JOY_RADIUS- STICK_RADIUS/2;
      const scale = len>max ? max/len : 1;
      stick.style.transform = \`translate(\${dx*scale}px, \${dy*scale}px)\`;
      const nx = (dx*scale)/max;
      const ny = (dy*scale)/max;
      input.ax = nx; input.ay = ny;
    }
    function resetStick(){ stick.style.transform='translate(0,0)'; input.ax=0; input.ay=0; }
    const joy = document.getElementById('joystick');
    joy.addEventListener('touchstart', (e)=>{
      const t = e.changedTouches[0];
      const rect = joy.getBoundingClientRect();
      joyCx = rect.width/2; joyCy = rect.height/2;
      joyActive=true;
      const dx = (t.clientX - rect.left) - joyCx;
      const dy = (t.clientY - rect.top) - joyCy;
      setStick(dx, dy);
    }, {passive:true});
    joy.addEventListener('touchmove', (e)=>{
      if(!joyActive) return;
      const t = e.changedTouches[0];
      const rect = joy.getBoundingClientRect();
      const dx = (t.clientX - rect.left) - joyCx;
      const dy = (t.clientY - rect.top) - joyCy;
      setStick(dx, dy);
    }, {passive:true});
    joy.addEventListener('touchend', ()=>{ joyActive=false; resetStick(); }, {passive:true});
    joy.addEventListener('touchcancel', ()=>{ joyActive=false; resetStick(); }, {passive:true});

    // Keyboard fallback
    window.addEventListener('keydown', e=>keys[e.key]=true);
    window.addEventListener('keyup', e=>keys[e.key]=false);

    // ====== Game Core ======
    function init(){
      const best = parseInt(localStorage.getItem('best')||'0',10); bestEl.textContent = best;
      // 플레이어 즉시 생성 (화면 중앙)
      player={ x: canvas.width/2, y: canvas.height/2, r:10, speed:4, hp:100, maxHp:100, color:'#ff0' };
      bullets=[]; healthPacks=[]; score=0; gameOver=false;
      spawnIntervalMs=1000; spawnTimerMs=0; difficultyTimerMs=0;
      bossSchedule=[3000,6000,9000]; nextBossIdx=0; bossActive=false; bossTimerMs=0; bossDurationMs=15000;
      lastHealThreshold=0; lastMaxHpThreshold=0; boss=null;
      // UI
      ui.style.display='block'; canvas.style.display='block'; joystick.style.display='block'; warningDiv.style.display='none';
      gameOverScreen.style.display='none'; mainMenu.style.display='none';
      updateHpBar(); scoreEl.textContent='0';
      lastTime = performance.now();
    }

    function update(dt){
      if(gameOver) return;
      const mx = input.ax * player.speed * dt/FRAME_REF + ((keys['ArrowRight']||keys['d']) - (keys['ArrowLeft']||keys['a']))*player.speed*dt/FRAME_REF;
      const my = input.ay * player.speed * dt/FRAME_REF + ((keys['ArrowDown']||keys['s']) - (keys['ArrowUp']||keys['w']))*player.speed*dt/FRAME_REF;
      player.x = Math.max(player.r, Math.min(canvas.width-player.r, player.x + mx));
      player.y = Math.max(player.r, Math.min(canvas.height-player.r, player.y + my));

      // 일반 탄환 생성(2발)
      spawnTimerMs += dt;
      if(spawnTimerMs>=spawnIntervalMs){
        spawnTimerMs-=spawnIntervalMs;
        bullets.push(Bullet.aimedFromEdge(), Bullet.aimedFromEdge());
      }
      // 난이도 점증
      difficultyTimerMs += dt;
      if(difficultyTimerMs>=5000){ difficultyTimerMs-=5000; spawnIntervalMs=Math.max(300, spawnIntervalMs-50); }

      // 힐팩 500점마다
      const healThr=(score|0)/500|0;
      if(healThr>lastHealThreshold){ lastHealThreshold=healThr; healthPacks.push(new HealthPack()); }

      // 2000점마다 최대 HP 증가
      const hpThr=(score|0)/2000|0;
      if(hpThr>lastMaxHpThreshold){
        lastMaxHpThreshold=hpThr;
        const inc = player.maxHp/15;
        player.maxHp += inc; player.hp += inc; updateHpBar();
      }

      // 보스
      maybeSpawnBoss();
      if(bossActive && boss){
        bossTimerMs += dt; boss.update(dt);
        const dx=player.x-boss.x, dy=player.y-boss.y; const half=boss.size/2;
        if(Math.abs(dx)<=half+player.r && Math.abs(dy)<=half+player.r){ player.hp -= 0.2*dt/FRAME_REF; }
        if(bossTimerMs>=15000 || boss.hp<=0){ bossActive=false; boss=null; updateBossBar(); }
      }

      // 탄환 갱신/충돌
      bullets.forEach(b=>b.update(dt));
      bullets=bullets.filter(b=>b.inBounds());
      bullets.forEach(b=>{ const dx=b.x-player.x, dy=b.y-player.y; if(Math.hypot(dx,dy)<b.r+player.r){ player.hp -= b.dmg; b.y=1e9; } });

      // 힐팩 충돌
      healthPacks.forEach((p,i)=>{
        const dx=p.x-player.x, dy=p.y-player.y;
        if(Math.hypot(dx,dy)<p.r+player.r){
          const missing = player.maxHp - player.hp;
          const healAmt = missing*0.10 + (player.maxHp/15); // 잃은 체력 10% + 일반탄 1발 분
          player.hp = Math.min(player.maxHp, player.hp + healAmt);
          healthPacks.splice(i,1);
        }
      });

      // 점수(고정 시간)
      score += (dt/1000)*SCORE_PER_SEC;
      scoreEl.textContent = (score|0);
      updateHpBar();
      if(player.hp<=0){ player.hp=0; endGame(); }
    }

    function draw(){
      // 경계선
      ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle='#fff'; ctx.fillRect(0,0,canvas.width,4); ctx.fillRect(0,0,4,canvas.height); ctx.fillRect(canvas.width-4,0,4,canvas.height); ctx.fillRect(0,canvas.height-4,canvas.width,4);
      // 플레이어
      ctx.fillStyle=player.color; ctx.beginPath(); ctx.arc(player.x,player.y,player.r,0,Math.PI*2); ctx.fill();
      // 보스
      if(bossActive && boss) boss.draw();
      // 힐팩 & 탄환
      healthPacks.forEach(p=>p.draw());
      bullets.forEach(b=>b.draw());
    }

    function loop(t){
      const dt = Math.min(50, t - lastTime); lastTime = t;
      update(dt); draw();
      if(!gameOver) requestAnimationFrame(loop);
    }

    function startGame(){
      init();
      requestAnimationFrame(loop);
    }
    function endGame(){
      gameOver=true; gameOverScreen.style.display='flex'; finalScore.textContent = (score|0);
      const best = parseInt(localStorage.getItem('best')||'0',10);
      if(score>best){ localStorage.setItem('best', score|0); bestEl.textContent = (score|0); }
    }

    // 이벤트
    btnStart.addEventListener('click', startGame);
    btnRetry.addEventListener('click', ()=>{ gameOverScreen.style.display='none'; mainMenu.style.display='flex'; ui.style.display='none'; joystick.style.display='none'; canvas.style.display='none'; });
    // 초기 상태
    (function initialUI(){
      mainMenu.style.display='flex';
      ui.style.display='none';
      canvas.style.display='none';
      joystick.style.display='none';
      gameOverScreen.style.display='none';
    })();
  </script>
</body>
</html>
